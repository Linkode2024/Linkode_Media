<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Room Screen Sharing</title>
    <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        button { margin-top: 10px; }
        #status, #log { margin-top: 20px; border: 1px solid #ccc; padding: 10px; height: 200px; overflow-y: auto; }
        #localVideo { width: 640px; height: 480px; background-color: #ddd; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>Study Room Screen Sharing</h1>
    <input type="text" id="roomId" placeholder="Enter Study Room Number">
    <button id="joinRoom">Join Room</button>
    <button id="startScreen" disabled>Start Screen Share</button>
    <button id="stopScreen" disabled>Stop Screen Share</button>
    <div id="status"></div>
    <div id="log"></div>
    <video id="localVideo" autoplay playsinline></video>

    <script>
        let producerTransport;
        let screenProducer;
        let currentRoom;
        let producerTransportId;

        const joinRoomBtn = document.getElementById('joinRoom');
        const startScreenBtn = document.getElementById('startScreen');
        const stopScreenBtn = document.getElementById('stopScreen');
        const roomIdInput = document.getElementById('roomId');
        const statusDiv = document.getElementById('status');
        const logDiv = document.getElementById('log');
        const localVideo = document.getElementById('localVideo');

        function log(message) {
            console.log(message);
            logDiv.innerHTML += `<p>${message}</p>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        const socket = io('https://localhost:3000', {
            withCredentials: true,
            transports: ['websocket']
        });

        socket.on('connect', () => {
            log('Connected to server');
            updateStatus('Connected to server');
        });

        socket.on('connect_error', (error) => {
            log('Connection error:', error);
            updateStatus('Connection error: ' + error.message);
        });

        joinRoomBtn.addEventListener('click', () => {
            const roomId = roomIdInput.value.trim();
            if (roomId) {
                currentRoom = roomId;
                socket.emit('join-room', roomId, 'user-' + Math.random().toString(36).substr(2, 9));
                log('Joining room: ' + roomId);
                updateStatus('Joining room: ' + roomId);
            } else {
                updateStatus('Please enter a room number');
            }
        });

        socket.on('get-rtp-capabilities', async (routerRtpCapabilities) => {
            log('Received RTP capabilities:', routerRtpCapabilities);
            updateStatus('Joined room successfully');
            await createProducerTransport();
            startScreenBtn.disabled = false;
        });

        async function createProducerTransport() {
            try {
                log('Creating producer transport...');
                const response = await new Promise((resolve) => {
                    socket.emit('create-producer-transport', currentRoom, resolve);
                });

                log('Received producer transport response:', response);

                if (response.error) {
                    throw new Error(response.error);
                }

                producerTransport = new RTCPeerConnection(response.params);
                producerTransportId = response.params.id;

                producerTransport.onicecandidate = ({ candidate }) => {
                    if (candidate) {
                        log('ICE candidate:', candidate);
                        socket.emit('ice-candidate', currentRoom, producerTransportId, candidate);
                    }
                };

                const offer = await producerTransport.createOffer();
                log('Created offer:', offer);
                await producerTransport.setLocalDescription(offer);

                const dtlsParameters = producerTransport.getConfiguration().certificates
                    ? producerTransport.getConfiguration().certificates[0].getFingerprints().map(fp => ({
                        algorithm: fp.algorithm,
                        value: fp.value
                    }))
                    : producerTransport.localDescription.sdp
                        .split('\r\n')
                        .filter(line => line.startsWith('a=fingerprint:'))
                        .map(line => {
                            const [, algorithm, fingerprint] = line.split(' ');
                            return { algorithm, value: fingerprint };
                        });

                log('DTLS parameters:', dtlsParameters);

                await new Promise((resolve, reject) => {
                    socket.emit('connect-producer-transport', currentRoom, producerTransportId, { dtlsParameters }, (response) => {
                        log('Connect producer transport response:', response);
                        if (response.error) {
                            reject(new Error(response.error));
                        } else {
                            resolve();
                        }
                    });
                });

                log('Producer transport created and connected');
                updateStatus('Producer transport created and connected');
            } catch (error) {
                log('Error creating producer transport:', error);
                updateStatus('Error creating producer transport: ' + error.message);
            }
        }

        startScreenBtn.addEventListener('click', async () => {
            try {
                log('Starting screen share...');
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const track = stream.getVideoTracks()[0];
                
                localVideo.srcObject = stream;
                
                log('Got screen share track:', track);
                
                const params = {
                    track,
                    encodings: [
                        { maxBitrate: 100000 },
                        { maxBitrate: 300000 },
                        { maxBitrate: 900000 }
                    ],
                    codecOptions: {
                        videoGoogleStartBitrate: 1000
                    }
                };
                
                const codecs = RTCRtpSender.getCapabilities('video').codecs;
                params.codecs = codecs.filter(codec => codec.mimeType === 'video/VP8').map((codec, index) => ({
                    ...codec,
                    payloadType: 96 + index
                }));
                
                log('Producing with params:', params);
                
                socket.emit('produce', currentRoom, producerTransportId, 'video', params, (response) => {
                    log('Produce response:', response);
                    if (response.error) {
                        updateStatus('Error starting screen share: ' + response.error);
                        return;
                    }
                    screenProducer = response.id;
                    socket.emit('start-screen-share', currentRoom, response.id);
                    updateStatus('Screen sharing started');
                    startScreenBtn.disabled = true;
                    stopScreenBtn.disabled = false;
                });

                track.onended = () => {
                    log('Screen share track ended');
                    stopScreenShare();
                };
            } catch (error) {
                log('Error accessing screen:', error);
                updateStatus('Error accessing screen: ' + error.message);
            }
        });

        stopScreenBtn.addEventListener('click', stopScreenShare);

        function stopScreenShare() {
            if (screenProducer) {
                log('Stopping screen share...');
                socket.emit('stop-screen-share', currentRoom, screenProducer);
                if (localVideo.srcObject) {
                    localVideo.srcObject.getTracks().forEach(track => track.stop());
                }
                localVideo.srcObject = null;
                updateStatus('Screen sharing stopped');
                startScreenBtn.disabled = false;
                stopScreenBtn.disabled = true;
                screenProducer = null;
            }
        }

        function updateStatus(message) {
            statusDiv.textContent = message;
            log('Status update: ' + message);
        }

        socket.on('screen-share-started', ({ producerId }) => {
            log('Screen share started by another user:', producerId);
            updateStatus('Screen share started by another user: ' + producerId);
        });

        socket.on('screen-share-stopped', ({ producerId }) => {
            log('Screen share stopped by another user:', producerId);
            updateStatus('Screen share stopped by another user: ' + producerId);
        });
    </script>
</body>
</html>